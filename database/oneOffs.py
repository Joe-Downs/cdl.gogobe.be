# Python Modules
import copy
import csv
import os
import sqlite3
# Third-Party Modules
# Custom Modules

# This module will hold functions which (most likely) will only be used a few
# times in initially creating the database. These functions will populate the
# database with data from various CSV files.

# ========================== Populate Database Tables ==========================

# populateAliases() populates the aliases of users given by aliases.csv into the
# aliases table of the database of the given cursor. aliases.csv is strictly
# formatted to simplify the import process. This strict format is: headers which
# read: "discordID,alias" (this allows the CSV to be mapped to a
# dictionary). DiscordIDs are not used because this file is created by a human
# and it's faster to copy the ID from Discord rather than look it up in the
# database. (Python can do that for us!)
def populateAliases(curs):
    with open("aliases.csv", newline = '') as csvAliases:
        aliasReader = csv.DictReader(csvAliases)
        for row in aliasReader:
            aliasCommand = """INSERT INTO aliases
(sqlID, userID, alias) VALUES (NULL, ?, ?)
"""
            discordID = int(row["discordID"])
            discordIDCommand = "SELECT sqlID FROM users WHERE discordID = ?"
            curs.execute(discordIDCommand, (discordID,))
            userID = curs.fetchone()[0]
            alias = row["alias"]
            curs.execute(aliasCommand, (userID, alias))
        csvAliases.close()

# computePlaces() takes the list of lists containing the names and points for
# each user and round and computes the places each user got. (Highest points is
# first, lowest is last by default) It returns a list of lists with a similar
# structure, except with places instead of points. If isGolfScoring is set to
# true, than the lowest value is first, and the highest is last.
def computePlaces(namesPointsList, isGolfScoring = False):
    # This is the list to be returned; to ensure it is the correct size, it is
    # just a copy of the points list. Point values will be replaced by place
    # values.
    namesPlacesList = copy.deepcopy(namesPointsList)
    # The list of names is always first, so we start at index 1 (the 2nd item).
    for index in range(1, len(namesPointsList)-1):
        roundColumn = copy.deepcopy(namesPointsList[index])
        # This keeps track of what place we're finding. It gets incremented or
        # decremented (depending if it's golf scoring) every time we find the
        # max number(s) in the round.
        if isGolfScoring:
            # Starts at the number of players and goes to 1.
            place = len(roundColumn)
        else:
            # Starts at 1 and goes to the number of players.
            place = 1
        # Repeat until all the points in the round are processed.
        while len(roundColumn) > 0:
            maxPoints = max(roundColumn)
            while roundColumn.count(maxPoints) >= 1:
                maxIndex = roundColumn.index(maxPoints)
                # If the point value is a negative number, then it's a special
                # case that must be replaced by a string for processing into the
                # database.
                if maxPoints == -1:
                    namesPlacesList[index][maxIndex] = "DNS"
                elif maxPoints == -2:
                    namesPlacesList[index][maxIndex] = "DNF"
                elif maxPoints == -3:
                    namesPlacesList[index][maxIndex] = "DSQ"
                else:
                    namesPlacesList[index][maxIndex] = place
                roundColumn.remove(maxPoints)
            if isGolfScoring:
                place -= 1
            else:
                place += 1
    #print(f"namesPlacesList: {namesPlacesList}")
    return namesPlacesList

# populateResults() populates the results given from the various CDL###.csv
# files in the results/ directory. These files have a fairly uniform format, but
# it's not very cut-and-dry. A little more parsing needs to be done than what is
# necessary for the other CSV files generated by me, by hand. For simplicity's
# sake, every file in the results/ directory is used, rather than checking the
# filenames.
def populateResults():
    names = []
    for cdlResult in os.listdir("results"):
        with open(f"results/{cdlResult}", newline = '') as csvResult:
            # columnList is a list of lists, where each index represents a
            # column in the table; the list within represents the rows in the
            # column.
            columnList = []
            isGolfScoring = False
            cdlReader = csv.reader(csvResult)
            for row in cdlReader:
                # If the second column's value is "Round 1", then that row is
                # the header row and must be saved for later.
                if row[1] == "Round 1":
                    header = row
                    # Append empty lists to the columnList: as many as there are
                    # rows (minus the final total).z
                    for index in range(0, len(row)-1):
                        columnList.append(list())
                if row[0].lower().startswith("group"):
                    # The group's letter is the 7th character of the group name:
                    # e.g., D is at index 6 in "Group D"
                    groupLetter = row[0][6]
                    for column in columnList:
                        column.append(groupLetter)
                elif row[0].lower() == "golf":
                    isGolfScoring = True
                elif row.count("") > 2:
                    pass
                else:
                    # If the row isn't a special row caught above, then it
                    # should be a regular row for users' scores.
                    for index in range(0, len(row)-1):
                        result = row[index]
                        try:
                            columnList[index].append(int(result))
                        except ValueError:
                            # The strings ("DNS", "DNF", "DSQ") must be removed
                            # from the columns, or else max() won't work.
                            if result == "DNS":
                                columnList[index].append(-1)
                            elif result == "DNF":
                                columnList[index].append(-2)
                            elif result == "DSQ":
                                columnList[index].append(-3)
                            else:
                                columnList[index].append(result)
            print("Points:")
            print(columnList)
            print("Places:")
            placesList = []
            for letter in ["A", "B", "C", "D"]:
                # Because slicing a list includes the lower bound and we don't
                # want the letter included, the start index is one after the
                # letter.
                startIndex = columnList[0].index(letter) + 1
                nextLetter = chr(ord(letter) + 1)
                try:
                    endIndex = columnList[0].index(nextLetter)
                except ValueError:
                    # The letter was not found = there are no more groups to
                    # worry about.
                    endIndex = len(columnList) - 1
                    break
                slicedList = list()
                for column in columnList:
                    slicedList.append(column[startIndex:endIndex])
                placesList = computePlaces(slicedList, isGolfScoring)
                print(placesList)
        csvResult.close()
    return names

# populateUsers() populates the users given by users.csv into the users table of
# the database of the given cursor. users.csv is strictly formatted to simplify
# the import process. This strict format is: headers which read:
# "discordID,username,status" (this allows the CSV to be mapped to a dictionary)
def populateUsers(curs):
    with open("users.csv", newline = '') as csvUsers:
        userReader = csv.DictReader(csvUsers)
        for row in userReader:
            userCommand = """INSERT INTO users
(sqlID, discordID, username, status) VALUES (NULL, ?, ?, ?)
"""
            discordID = int(row["discordID"])
            username = row["username"]
            status = row["status"]
            curs.execute(userCommand, (discordID, username, status,))
    csvUsers.close()
